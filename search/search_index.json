{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Outline Skribi implements Eta templating in Obsidian in a manner akin to Scribunto , the scripted template framework used by MediaWiki. Create a template, pass variables to it, and render the output in your notes. Skribi enables non-destructive templating: seamlessly integrate complex HTML into your notes, instanced from a single source, without HTML clutter or having to repeat yourself. You can even construct normally impossible element structures, such as rendering markdown inside of block elements - including Obsidian syntax media embedding. Inside a skribi, you have access to Eta's powerful templating tools and javascript, letting you imbue your template objects with dynamic behaviours. Usage Details Skribi recognizes inline code elements with curly brackets {} and codeblocks of type skribi . The contents are processed with Eta, and the output is rendered in place of the code element. The output is updated automatically as you make changes. These render very quickly - without any scripting that causes a delay (like file reads), skribi render times are practically instant. Because they are rendered asynchronously, many skribis can be placed in a document without delaying a note's rendering. Skribi has two primary modes: template and non-template. Templates are loaded from files in the configured template folder, and invoked with a colon. They may then be followed by pipe-separated values. Note that any pipes in the values must be escaped. Note: code elements with the class no-skribi will be ignored regardless of content. See: Skribi Syntax and Template Invocation","title":"Outline"},{"location":"#outline","text":"Skribi implements Eta templating in Obsidian in a manner akin to Scribunto , the scripted template framework used by MediaWiki. Create a template, pass variables to it, and render the output in your notes. Skribi enables non-destructive templating: seamlessly integrate complex HTML into your notes, instanced from a single source, without HTML clutter or having to repeat yourself. You can even construct normally impossible element structures, such as rendering markdown inside of block elements - including Obsidian syntax media embedding. Inside a skribi, you have access to Eta's powerful templating tools and javascript, letting you imbue your template objects with dynamic behaviours.","title":"Outline"},{"location":"#usage-details","text":"Skribi recognizes inline code elements with curly brackets {} and codeblocks of type skribi . The contents are processed with Eta, and the output is rendered in place of the code element. The output is updated automatically as you make changes. These render very quickly - without any scripting that causes a delay (like file reads), skribi render times are practically instant. Because they are rendered asynchronously, many skribis can be placed in a document without delaying a note's rendering. Skribi has two primary modes: template and non-template. Templates are loaded from files in the configured template folder, and invoked with a colon. They may then be followed by pipe-separated values. Note that any pipes in the values must be escaped. Note: code elements with the class no-skribi will be ignored regardless of content. See: Skribi Syntax and Template Invocation","title":"Usage Details"},{"location":"commands/","text":"Skribi command IDs are prefixed by obsidian-skribi . View Indices View Templates ( view-templates ): Opens the Template Index Modal , which displays a list of loaded templates and stylesheets. View Scripts ( view-scripts ): Opens the Script Index Modal , which displays a list of loaded script files. Insert Skribi Opens a prompt to insert a template. Will prompt you for variables, as defined in the Template Metadata . Render Template / Render Preset Opens a modal and renders a template within. See Render Modal for details. Reload Skribis Causes all extant skribis to rerender themselves. Though skribis will automatically rerender themselves if any of their source assets (template, script, stylesheet) are updated, this command is provided just in case. Reload Scripts Reloads scripts from the script directory. Scripts should automatically reload, but this command is provided just in case. Performance Test This command opens a modal that can perform bulk renders and report the results. This is intended as a utility for those who are making complex skribis and want an indication of execution times. The Text To Evaluate field is autofilled from highlighted text, or the clipboard contents, if any is found. The text in this field is treated as the text of the virtual skribi that will be evaluated. Evaluation Iterations is the number of times to render the skribi. The result will be an averaged value of the processing times. I recommend using 10, but I've only tested on my machine. Using very high values will overload the system, causing each render to be slower, and returning values not representative of the expected processing time during normal use. Eval As Individual Blocks toggles between placing all the skribis into one block, as would be the case with multiple inline skribis, or as individual blocks. Notes about results Because of how async code works in javascript, using promises introduces some time-bloat that isn't really indicative of the actual execution times. You can see that even evaluating empty text takes time (on my machine, about 2.6ms) where in reality it's nearly instant. This extra time is generated by the nature of promises. I'll look into adding a synchronous evaluation method in the future. Generally, you don't really need to worry about the performance unless you're doing heavy operations.","title":"Commands"},{"location":"commands/#view-indices","text":"View Templates ( view-templates ): Opens the Template Index Modal , which displays a list of loaded templates and stylesheets. View Scripts ( view-scripts ): Opens the Script Index Modal , which displays a list of loaded script files.","title":"View Indices"},{"location":"commands/#insert-skribi","text":"Opens a prompt to insert a template. Will prompt you for variables, as defined in the Template Metadata .","title":"Insert Skribi"},{"location":"commands/#render-template-render-preset","text":"Opens a modal and renders a template within. See Render Modal for details.","title":"Render Template / Render Preset"},{"location":"commands/#reload-skribis","text":"Causes all extant skribis to rerender themselves. Though skribis will automatically rerender themselves if any of their source assets (template, script, stylesheet) are updated, this command is provided just in case.","title":"Reload Skribis"},{"location":"commands/#reload-scripts","text":"Reloads scripts from the script directory. Scripts should automatically reload, but this command is provided just in case.","title":"Reload Scripts"},{"location":"commands/#performance-test","text":"This command opens a modal that can perform bulk renders and report the results. This is intended as a utility for those who are making complex skribis and want an indication of execution times. The Text To Evaluate field is autofilled from highlighted text, or the clipboard contents, if any is found. The text in this field is treated as the text of the virtual skribi that will be evaluated. Evaluation Iterations is the number of times to render the skribi. The result will be an averaged value of the processing times. I recommend using 10, but I've only tested on my machine. Using very high values will overload the system, causing each render to be slower, and returning values not representative of the expected processing time during normal use. Eval As Individual Blocks toggles between placing all the skribis into one block, as would be the case with multiple inline skribis, or as individual blocks.","title":"Performance Test"},{"location":"commands/#notes-about-results","text":"Because of how async code works in javascript, using promises introduces some time-bloat that isn't really indicative of the actual execution times. You can see that even evaluating empty text takes time (on my machine, about 2.6ms) where in reality it's nearly instant. This extra time is generated by the nature of promises. I'll look into adding a synchronous evaluation method in the future. Generally, you don't really need to worry about the performance unless you're doing heavy operations.","title":"Notes about results"},{"location":"settings/","text":"Settings Template Directory Files in this folder are loaded as templates. Script Folder JS files in this folder are loaded as modules. For details, see Scriptloading . Auto Reload Enables the automatic rerendering of skribis when either their source template or the script cache changes. Error Logging Logs any render errors to the console, rather than only as a tooltip on the errored skribi. It's off by default because it spams the console while you're editing. Verbose Logging Provides additional information in the console. Note that the displayed render times are inflated by async overhead. Also, the first evaluation of a skribi may take longer than subsequent evals. If you need more profiling tools, try the Performance Test command. Template Suggestions Presents a suggestion popover when invoking a template, similar to the suggestions when creating a wikilink. Will suggest templates as well as any property keys defined in the templates frontmatter (like the insertion modal). CSS Animations Toggles animations (adds the class 'skribi-anims' to the document body). There aren't that many animations, but just in case. Render Presets Defines presets used to generate render modal commands .","title":"Settings"},{"location":"settings/#settings","text":"","title":"Settings"},{"location":"settings/#template-directory","text":"Files in this folder are loaded as templates.","title":"Template Directory"},{"location":"settings/#script-folder","text":"JS files in this folder are loaded as modules. For details, see Scriptloading .","title":"Script Folder"},{"location":"settings/#auto-reload","text":"Enables the automatic rerendering of skribis when either their source template or the script cache changes.","title":"Auto Reload"},{"location":"settings/#error-logging","text":"Logs any render errors to the console, rather than only as a tooltip on the errored skribi. It's off by default because it spams the console while you're editing.","title":"Error Logging"},{"location":"settings/#verbose-logging","text":"Provides additional information in the console. Note that the displayed render times are inflated by async overhead. Also, the first evaluation of a skribi may take longer than subsequent evals. If you need more profiling tools, try the Performance Test command.","title":"Verbose Logging"},{"location":"settings/#template-suggestions","text":"Presents a suggestion popover when invoking a template, similar to the suggestions when creating a wikilink. Will suggest templates as well as any property keys defined in the templates frontmatter (like the insertion modal).","title":"Template Suggestions"},{"location":"settings/#css-animations","text":"Toggles animations (adds the class 'skribi-anims' to the document body). There aren't that many animations, but just in case.","title":"CSS Animations"},{"location":"settings/#render-presets","text":"Defines presets used to generate render modal commands .","title":"Render Presets"},{"location":"states/","text":"State Indicators When a skribi is not able to display a rendered result, a state indicator will be rendered in its place. These indicators are code elements with the text 'SK', typically with an icon. Any described animations will not occur if the setting 'CSS Animations' is set to false. Some indicators can be clicked on to provide additional information (in this case, the color will change when hovered). Errors Red with a boxed exclamation mark ( skr-error ) indicates that an error was thrown during invocation. Hover over it to see a tooltip describing the error, or click to open the error modal, which will display the error in more detail. Gray with a red-underlined 'JS' or '\u03b7' ( skr-syntax-js , skr-syntax-eta ) indicates a Javascript or Eta parsing error, respectively. Hover or click for more detailed information, which Skribi will attempt to provide. Orange with an exclamation mark in a triangle ( skr-abort ) indicates that an abort command was invoked by the skribi function. This only occurs when user code invokes sk.abort , and is intended to help differentiate user-intended error states. Other A blue spinning circle-arrow ( skr-waiting ) indicates that the template being invoked has not yet been loaded. It will be replaced once the template is loaded and rendered. This happens briefly if there are skribis on first page after launching Obsidian. It may also occur if the template cache is recompiled. A green writing quill ( skr-evaluating ) indicates that the skribi is currently being evaluated. Most skribi evaluations are too quick to see, so this most often occurs when the skribi function is awaiting lengthy operation. A purple spinning spiral ( skr-depth ) indicates that a transclusion could not be rendered because the depth limit has been reached. A skribi-invoking codespan with light blue text ( skr-stasis ) indicates that invocation was not possible because the depth limit has been reached. Amber with no icon ( skr-self ) indicates that the skribi was not rendered because it is being rendered within its own definition. (If you want this behaviour for some reason let me know and I'll add an option for it.)","title":"Indicators"},{"location":"states/#state-indicators","text":"When a skribi is not able to display a rendered result, a state indicator will be rendered in its place. These indicators are code elements with the text 'SK', typically with an icon. Any described animations will not occur if the setting 'CSS Animations' is set to false. Some indicators can be clicked on to provide additional information (in this case, the color will change when hovered). Errors Red with a boxed exclamation mark ( skr-error ) indicates that an error was thrown during invocation. Hover over it to see a tooltip describing the error, or click to open the error modal, which will display the error in more detail. Gray with a red-underlined 'JS' or '\u03b7' ( skr-syntax-js , skr-syntax-eta ) indicates a Javascript or Eta parsing error, respectively. Hover or click for more detailed information, which Skribi will attempt to provide. Orange with an exclamation mark in a triangle ( skr-abort ) indicates that an abort command was invoked by the skribi function. This only occurs when user code invokes sk.abort , and is intended to help differentiate user-intended error states. Other A blue spinning circle-arrow ( skr-waiting ) indicates that the template being invoked has not yet been loaded. It will be replaced once the template is loaded and rendered. This happens briefly if there are skribis on first page after launching Obsidian. It may also occur if the template cache is recompiled. A green writing quill ( skr-evaluating ) indicates that the skribi is currently being evaluated. Most skribi evaluations are too quick to see, so this most often occurs when the skribi function is awaiting lengthy operation. A purple spinning spiral ( skr-depth ) indicates that a transclusion could not be rendered because the depth limit has been reached. A skribi-invoking codespan with light blue text ( skr-stasis ) indicates that invocation was not possible because the depth limit has been reached. Amber with no icon ( skr-self ) indicates that the skribi was not rendered because it is being rendered within its own definition. (If you want this behaviour for some reason let me know and I'll add an option for it.)","title":"State Indicators"},{"location":"misc/index_modal/","text":"Index Modals There are a number of modals that display potentially helpful indices. Template Index An index of your templates, split into three categories. Each entry is listed with a tag denoting the file extension type, followed by the entry name. Files with the extension .md may be clicked on to open the source file in Obsidian. The list will automatically refresh whenever the template cache is updated, which occurs when a template is edited. Thus, you may leave the index open while you edit templates in an external editor, and see their entry move to/from the error list immediately. You may also force the list to refresh with the Refresh Index button, just in case. The Recompile All button does exactly that: tells Skribi to recompile all templates, as if it were loading. The list is then refreshed. Categories: - Errored Templates : If any templates failed to compile, they will be displayed in this category. Such templates will have an error indicator displayed that you can click to open an error modal with more information. - Templates : Templates that loaded normally. - Style Snippets : Loaded stylesheets , aka any file in the template directory with the .css extension. Like the Errored Templates list, this list will not appear if no stylesheets were loaded. Note that stylesheets are currently not evaluated for validity, and so will not encounter or display errors like templates do, regardless of whether or not they contain valid CSS. Script Index An index of your scripts, split into two categories: Errored Scripts and Scripts . Like the Template Index, the Refresh Index and Recompile All buttons will refresh the index and recompile all scripts, respectively. Script files that failed to load will be in Errored Scripts , with an error indicator that may be clicked to display a more detailed error modal. Script files that loaded will be in Scripts .","title":"Index Modals"},{"location":"misc/index_modal/#index-modals","text":"There are a number of modals that display potentially helpful indices.","title":"Index Modals"},{"location":"misc/index_modal/#template-index","text":"An index of your templates, split into three categories. Each entry is listed with a tag denoting the file extension type, followed by the entry name. Files with the extension .md may be clicked on to open the source file in Obsidian. The list will automatically refresh whenever the template cache is updated, which occurs when a template is edited. Thus, you may leave the index open while you edit templates in an external editor, and see their entry move to/from the error list immediately. You may also force the list to refresh with the Refresh Index button, just in case. The Recompile All button does exactly that: tells Skribi to recompile all templates, as if it were loading. The list is then refreshed. Categories: - Errored Templates : If any templates failed to compile, they will be displayed in this category. Such templates will have an error indicator displayed that you can click to open an error modal with more information. - Templates : Templates that loaded normally. - Style Snippets : Loaded stylesheets , aka any file in the template directory with the .css extension. Like the Errored Templates list, this list will not appear if no stylesheets were loaded. Note that stylesheets are currently not evaluated for validity, and so will not encounter or display errors like templates do, regardless of whether or not they contain valid CSS.","title":"Template Index"},{"location":"misc/index_modal/#script-index","text":"An index of your scripts, split into two categories: Errored Scripts and Scripts . Like the Template Index, the Refresh Index and Recompile All buttons will refresh the index and recompile all scripts, respectively. Script files that failed to load will be in Errored Scripts , with an error indicator that may be clicked to display a more detailed error modal. Script files that loaded will be in Scripts .","title":"Script Index"},{"location":"misc/localization/","text":"Localization Skribi has support for localization of its UI elements and other strings like the hover texts. At this time, it does not actually have any localization. If you're using Skribi at all (or are reading this), you probably understand English fairly well, but maybe having disparate languages in your UI bothers you - and if you're like me then anything that bothers you even slightly gets obliterated by space lasers elegantly resolved through a generous contribution of your time in the form of a pull request. If you'd like to contribute, but don't know anything about git or npm or just don't want to make a pull request (and who does), just make a copy of the EN file, translate the lines on the right, and send it to me. If you want to add it yourself, it's the same thing but add it to locales in babel.ts instead of sending it to me. Here are the locale codes - although Obsidian only supports like 12 of those.","title":"Localization"},{"location":"misc/localization/#localization","text":"Skribi has support for localization of its UI elements and other strings like the hover texts. At this time, it does not actually have any localization. If you're using Skribi at all (or are reading this), you probably understand English fairly well, but maybe having disparate languages in your UI bothers you - and if you're like me then anything that bothers you even slightly gets obliterated by space lasers elegantly resolved through a generous contribution of your time in the form of a pull request. If you'd like to contribute, but don't know anything about git or npm or just don't want to make a pull request (and who does), just make a copy of the EN file, translate the lines on the right, and send it to me. If you want to add it yourself, it's the same thing but add it to locales in babel.ts instead of sending it to me. Here are the locale codes - although Obsidian only supports like 12 of those.","title":"Localization"},{"location":"misc/render_modal/","text":"Render Modal The render modal is a modal that renders a single skribi template. It can be invoked in one of two ways: The Render Template command, which will prompt with a list of templates. A Render Preset command, generated by the configured render presets. When evaluating in a modal, sk.ctx.file will be null. The modal element will have an attribute skribi-render-modal-key with the value set to the rendered template key, for template-specific modal styling. Render Presets Render presets are configured template invocations that each create an Obsidian command, which can be assigned a hotkey like any other command. In this way, templates can be used as modals if desired. Preset commands have the name \"Skribi: Render Preset - Preset Name \" and the id obsidian-skribi:render-preset_$ , where $ is the unique numerical id assigned to the preset. You can see the numerical id in your Skribi installation's data.json . Saved hotkeys will persist if Skribi is disabled or the preset name is changed, but will be lost is the preset is deleted. Render presets are listed in the Skribi Settings tab. To add a new entry, press the + button. An entry can be deleted with the entry's x button. The first field is the preset name, which is visible in the command name. The second field is the template key. The third field is the arguments, which should start with a pipe | and be written in the same format as a normal template invocation. Like any other skribi templates in render modals will be reloaded if one of their sources is updated, without needing to re-open the modal (so long as Auto Reload is enabled).","title":"Render Modal"},{"location":"misc/render_modal/#render-modal","text":"The render modal is a modal that renders a single skribi template. It can be invoked in one of two ways: The Render Template command, which will prompt with a list of templates. A Render Preset command, generated by the configured render presets. When evaluating in a modal, sk.ctx.file will be null. The modal element will have an attribute skribi-render-modal-key with the value set to the rendered template key, for template-specific modal styling.","title":"Render Modal"},{"location":"misc/render_modal/#render-presets","text":"Render presets are configured template invocations that each create an Obsidian command, which can be assigned a hotkey like any other command. In this way, templates can be used as modals if desired. Preset commands have the name \"Skribi: Render Preset - Preset Name \" and the id obsidian-skribi:render-preset_$ , where $ is the unique numerical id assigned to the preset. You can see the numerical id in your Skribi installation's data.json . Saved hotkeys will persist if Skribi is disabled or the preset name is changed, but will be lost is the preset is deleted. Render presets are listed in the Skribi Settings tab. To add a new entry, press the + button. An entry can be deleted with the entry's x button. The first field is the preset name, which is visible in the command name. The second field is the template key. The third field is the arguments, which should start with a pipe | and be written in the same format as a normal template invocation. Like any other skribi templates in render modals will be reloaded if one of their sources is updated, without needing to re-open the modal (so long as Auto Reload is enabled).","title":"Render Presets"},{"location":"scripting/context/","text":"Context The string content of a skribi is parsed by Eta into a function, which returns the object tR , which is rendered to markdown and appended to the container element. This means that any evaluated javascript inside of the skribi is invoked within the function context. Within said context, a number of functions, variables, references, and helper components are available to you. Local Scope Variables The following properties are defined in the local scope. This makes them restricted keys (don't assign to them or something might break). Object Description this The template function's bound `this` object. scope Internal object used to provide objects to the local scope. You may inspect this object to view the provided objects. E , cb Internal Eta values, do not assign to them. tR The string that will be returned by the template function. sk Skribi Module - Contains various skribi objects and functions, including template variables. js Scriptloader Module - Contains JS functions and function-containing objects loaded from the configured Script Directory int Integration Modules - Contains any loaded integration modules. These modules will throw an error if accessed without the relevant plugin enabled. obsidian Obsidian Module - Contains Obsidian functions. moment Moment Module - A reference to the global moment object, a powerful date and time manipulation tool. See MomentJS for documentation.","title":"Context"},{"location":"scripting/context/#context","text":"The string content of a skribi is parsed by Eta into a function, which returns the object tR , which is rendered to markdown and appended to the container element. This means that any evaluated javascript inside of the skribi is invoked within the function context. Within said context, a number of functions, variables, references, and helper components are available to you.","title":"Context"},{"location":"scripting/context/#local-scope-variables","text":"The following properties are defined in the local scope. This makes them restricted keys (don't assign to them or something might break). Object Description this The template function's bound `this` object. scope Internal object used to provide objects to the local scope. You may inspect this object to view the provided objects. E , cb Internal Eta values, do not assign to them. tR The string that will be returned by the template function. sk Skribi Module - Contains various skribi objects and functions, including template variables. js Scriptloader Module - Contains JS functions and function-containing objects loaded from the configured Script Directory int Integration Modules - Contains any loaded integration modules. These modules will throw an error if accessed without the relevant plugin enabled. obsidian Obsidian Module - Contains Obsidian functions. moment Moment Module - A reference to the global moment object, a powerful date and time manipulation tool. See MomentJS for documentation.","title":"Local Scope Variables"},{"location":"scripting/errors/","text":"Misc Embeds Media embeds within skribis are rendered automatically, even when contained in block elements. Skribis within transclusions are rendered as well. Currently, PDFs and block-specific transclusions are not supported. Recursion Skribis use a number of methods to track their nesting depth through skribi-in-skribis, embedded transclusions, and mixtures thereof. It's a bit more restrictive than it probably needs to be - at some point I'll add a setting to alter the limit. I'm ~97% sure that skribis will not recurse infinitely under normal circumstances, but it might be possible if you tried really hard. In the event of an infinite recursion, Obsidian will freeze. In all of my testing, ending the task and reopening Obsidian was enough, as the page it opened to would be the previously closed one rather than the page that recursed. In the event that reopening Obsidian immediately freezes again (which never occured in testing I swear), I recommend either editing the offending file/template externally, or removing 'obsidian-skribi' from .obsidian/community-plugins.json . If you discover an unhandled recursion case, please report it by opening an issue on the repo . Error Handling When an error is thrown during skribi evaluation, the render will be aborted and replaced with an red error element. If you hover over the element, you will see the error message. If you want it as text, inspect the element and the error will be available under the title attribute. Most error cases should have descriptive messages (insofar as typescript has descriptive errors, that is) - if it says something like 'Skribi: Unknown Error' then I probably made a mistake somewhere and you should let me know. By throwing an error yourself, or calling the utility function sk.abort() , the execution of the skribi function is aborted and an error element is rendered with the error message as a tooltip, like any other error. Also, if you log anything to the console, you can click on the VMXXXX trace to view the compiled function. This is helpful for understanding exactly what's actually happening internally. If you're getting a SyntaxError: Unexpected token and you're really super certain that it should be parsing, check that your code does not contain escaped characters such as non-breaking spaces ( &nbsp; ), which render as normal spaces. Rather obnoxiously, any code copy-pasted from this documentation will have these villanous false spaces. I'll look into a fix. Async If the compiled string contains await anywhere (including as plaintext), the template function will be compiled to a promise. While awaiting the resolution of the template function, a placeholder element will be rendered - similar to an error element (but green!). This element will be replaced with the actual element (accessible in sk.child.el ) upon resolution, which means that sk.child.el is not connected to the document until after resolution. To execute code after resolution, use sk.child.registerPost()","title":"Misc"},{"location":"scripting/errors/#misc","text":"","title":"Misc"},{"location":"scripting/errors/#embeds","text":"Media embeds within skribis are rendered automatically, even when contained in block elements. Skribis within transclusions are rendered as well. Currently, PDFs and block-specific transclusions are not supported.","title":"Embeds"},{"location":"scripting/errors/#recursion","text":"Skribis use a number of methods to track their nesting depth through skribi-in-skribis, embedded transclusions, and mixtures thereof. It's a bit more restrictive than it probably needs to be - at some point I'll add a setting to alter the limit. I'm ~97% sure that skribis will not recurse infinitely under normal circumstances, but it might be possible if you tried really hard. In the event of an infinite recursion, Obsidian will freeze. In all of my testing, ending the task and reopening Obsidian was enough, as the page it opened to would be the previously closed one rather than the page that recursed. In the event that reopening Obsidian immediately freezes again (which never occured in testing I swear), I recommend either editing the offending file/template externally, or removing 'obsidian-skribi' from .obsidian/community-plugins.json . If you discover an unhandled recursion case, please report it by opening an issue on the repo .","title":"Recursion"},{"location":"scripting/errors/#error-handling","text":"When an error is thrown during skribi evaluation, the render will be aborted and replaced with an red error element. If you hover over the element, you will see the error message. If you want it as text, inspect the element and the error will be available under the title attribute. Most error cases should have descriptive messages (insofar as typescript has descriptive errors, that is) - if it says something like 'Skribi: Unknown Error' then I probably made a mistake somewhere and you should let me know. By throwing an error yourself, or calling the utility function sk.abort() , the execution of the skribi function is aborted and an error element is rendered with the error message as a tooltip, like any other error. Also, if you log anything to the console, you can click on the VMXXXX trace to view the compiled function. This is helpful for understanding exactly what's actually happening internally. If you're getting a SyntaxError: Unexpected token and you're really super certain that it should be parsing, check that your code does not contain escaped characters such as non-breaking spaces ( &nbsp; ), which render as normal spaces. Rather obnoxiously, any code copy-pasted from this documentation will have these villanous false spaces. I'll look into a fix.","title":"Error Handling"},{"location":"scripting/errors/#async","text":"If the compiled string contains await anywhere (including as plaintext), the template function will be compiled to a promise. While awaiting the resolution of the template function, a placeholder element will be rendered - similar to an error element (but green!). This element will be replaced with the actual element (accessible in sk.child.el ) upon resolution, which means that sk.child.el is not connected to the document until after resolution. To execute code after resolution, use sk.child.registerPost()","title":"Async"},{"location":"scripting/examples/","text":"Examples I'll add plenty of examples here at some point. Using sk.render() Takes a string, renders it to markdown, and outputs the HTML as text. Placing this within a raw tag ( <%~ %> in a template or {~ } in a doc) will then render the HTML as elements (if it parses), whereas in an interpolate tag you'll just get the escaped HTML as text. HTML in a template will already render like any other HTML written in a page, but this is useful to render markdown elements inside of block elements (which Obsidian will not process markdown inside of). For example, <div> ![[<%=sk.v.imgpath%>]] </div> will render as a div with the text ![[imgpath]] , but <div> <%~ sk.render(`![[${sk.v.imgpath}]]`)%> </div> will render as an image embed span with src imgpath inside the div. As an example of the {{ }} tags, you could achieve the same with {{ <div><%~sk.render(`![[${sk.v.imgpath}]]`)%></div> }} . Because post processors are not applied to block-level elements, skribis instead of block level elements will not render, even if you create the code span with html. However, inside of a rendered skribi, nested skribis will render even inside of block elements, and may be created with sk.render(\"`{}`\") or <code>{ }</code> , to a depth of 5 (will add a setting to increase limit later). You can also call a template directly in javascript with the Eta function include() . Note: the markdown renderer likes to embed everything in <p> s and <div> s. I'm not sure the best way to deal with that yet, but it's not really a problem - just kind of clutters the DOM a bit. When styling your templates, make sure to use the inspector to see the actual structure of your rendered elements. Also, the output is always placed in a div with the attribute skribi , with the value set to the name of the template. In CSS, you can target these with div[skribi=\"name\"] . div[skribi] will select all skribis. Using sk.child.registerInterval() Here is a very simple example of creating an updating clock. Note that the documentation system I'm using replaces spaces in codeblocks with non-breaking spaces , so copy-pasting from the code block below will not work (sorry about that). <% let time = moment().format('HH:mm:ss') sk.child.registerInterval(() => sk.child.reload(), 1) %> <%=time%>","title":"Examples"},{"location":"scripting/examples/#examples","text":"I'll add plenty of examples here at some point.","title":"Examples"},{"location":"scripting/examples/#using-skrender","text":"Takes a string, renders it to markdown, and outputs the HTML as text. Placing this within a raw tag ( <%~ %> in a template or {~ } in a doc) will then render the HTML as elements (if it parses), whereas in an interpolate tag you'll just get the escaped HTML as text. HTML in a template will already render like any other HTML written in a page, but this is useful to render markdown elements inside of block elements (which Obsidian will not process markdown inside of). For example, <div> ![[<%=sk.v.imgpath%>]] </div> will render as a div with the text ![[imgpath]] , but <div> <%~ sk.render(`![[${sk.v.imgpath}]]`)%> </div> will render as an image embed span with src imgpath inside the div. As an example of the {{ }} tags, you could achieve the same with {{ <div><%~sk.render(`![[${sk.v.imgpath}]]`)%></div> }} . Because post processors are not applied to block-level elements, skribis instead of block level elements will not render, even if you create the code span with html. However, inside of a rendered skribi, nested skribis will render even inside of block elements, and may be created with sk.render(\"`{}`\") or <code>{ }</code> , to a depth of 5 (will add a setting to increase limit later). You can also call a template directly in javascript with the Eta function include() . Note: the markdown renderer likes to embed everything in <p> s and <div> s. I'm not sure the best way to deal with that yet, but it's not really a problem - just kind of clutters the DOM a bit. When styling your templates, make sure to use the inspector to see the actual structure of your rendered elements. Also, the output is always placed in a div with the attribute skribi , with the value set to the name of the template. In CSS, you can target these with div[skribi=\"name\"] . div[skribi] will select all skribis.","title":"Using sk.render()"},{"location":"scripting/examples/#using-skchildregisterinterval","text":"Here is a very simple example of creating an updating clock. Note that the documentation system I'm using replaces spaces in codeblocks with non-breaking spaces , so copy-pasting from the code block below will not work (sorry about that). <% let time = moment().format('HH:mm:ss') sk.child.registerInterval(() => sk.child.reload(), 1) %> <%=time%>","title":"Using sk.child.registerInterval()"},{"location":"scripting/modules/integrations/","text":"Integrations If certain plugins are found to be loaded, an object containing functions for interacting with the plugin will be available in the int object. When the relevant plugin is not loaded, accessing the module will throw an error, which (like any error) will abort the render if not caught with a try catch block. If you would like integration with another plugin, you may make a request by opening an issue on the Skribi repository. Dataview int.dv Currently this is just a reference to the plugin API (NOT the inline API like dataviewjs). I'm considering making this a wrapper with all the gizmos (helper functions). For example: to render a dataview table, one would call int . dv . table ( tableColumns , tableData , sk . child . el , sk . child . c , this . file . path ) . Note that dataview render functions like dv.table are not synchronous and do not return a table object or promise. If you want to interact with the resulting element in code, you'll need to await a DOM observer or something. Weather int.weather A wrapper for the WeatherPlugin API, with some utility functions. Access the current weather cache with int.weather.dispenseCache() . Better documentation for this will be added when Weather is released.","title":"Integrations"},{"location":"scripting/modules/integrations/#integrations","text":"If certain plugins are found to be loaded, an object containing functions for interacting with the plugin will be available in the int object. When the relevant plugin is not loaded, accessing the module will throw an error, which (like any error) will abort the render if not caught with a try catch block. If you would like integration with another plugin, you may make a request by opening an issue on the Skribi repository.","title":"Integrations"},{"location":"scripting/modules/scriptloader/","text":"Scriptloader Any .js files inside of the configured Script Directory are automatically loaded by Skribi, and their exported properties made available in the js object. Any file modifications, additions, or deletions are detected and the modules reloaded automatically. Note: Obsidian by default does not show unrecognized file extensions in the file explorer, so .js files will not be visible. You may use a plugin such as CodeView to allow Obsidian to show JS files in the file explorer (as well as edit them within Obsidian). Personally, I use VSCode to edit my scriptloader scripts, by adding my script folder to my VSCode workspace. If for whatever reason you find the need to update the scriptloader manually (though this should never be necessary), you may either reload Obsidian or use the Skribi: Reload Scripts command. Exporting A module's exports consist of any properties belonging to the module.exports object. To export a property, assign to a property thereof, ex: module.exports.foo = property . Assigning to module.exports will overwrite the export object, which may or may not be desirable: module.exports = {fe, fi, fo} . In the following example, note that first function has no key, while the second does - functions are implicitly keyed with their name. This is not the case for other types, like numbers or strings - module.exports = {'foo', 2} is a syntax error. The statement module.exports = {fuctionOne, functionTwo: otherFunctionName, foo: 'fum'} would load as: js.moduleName: { functionOne: \u0192 functionOne() functionTwo: \u0192 otherFunctionName() foo: \"fum\" } Export Details The scriptloader has a couple extra features. Firstly, if you assign a string to exports._name , the file will be loaded under that string rather than the filename. Second, if you assign only one value (not counting _name ) to exports , that function will be available directly as js.moduleName() . If multiple values are present, the functions will be inside of js.moduleName , as in the example. This is a convenience feature - to prevent it, simply export more than one value. Or ask me to add a setting. When only one property is exported, the module key is determined by: module.exports._name , if it is a string. The key of the single value. Remember that functions are implicitly keyed. When multiple properties are exported, the module key is determined by: module.exports._name , if it is a string. The name of the source file. Tip: To inspect the js object, call console.log(js) in an evaluation tag. This will display the object in the dev console. If verbose logging is enabled, the loader will log whenever it loads a JS file. Additionally, a potentially confusing quirk of CJS module exports is the difference between module.exports and exports : the former is the actual object, while the latter is a shorthand proxy. You may assign to the properties of both objects and all will export successfully, but if you assign to either of them, this functionality will break. For example, exports = {foo} or module.exports = {foo} will cause exports to no longer contribute to the exported module - in this case, only module.exports will be exported. However, exports.foo = foo; module.exports.fum = fum; will load both foo and fum . For more information about this behavior, see Module Exports Shortcut . For information about exports in general, see Module Exports . About Script Context The skribi context is just a teensy bit convoluted, especially if you're not familiar with this part of JS, so here's some extra info. Firstly, script functions are by default evaluated in their module closure, with no knowledge of the skribi context. Because of this, you do not need to export all of the definitions in your module - only the ones you want to access from skribi (See Javascript Closures and CommonJS Modules ). But what if we want to call skribi functions from the script? To easily give a script function access to the skribi context, you can pass the return of sk.getEnv() as an argument. In the script, that argument variable will now contain everything you normally have access to: js , int , etc. For example: js.func(sk.getEnv()) with the script function func(obj){console.log(obj.sk.ctx.file.basename)}; module.exports = {func}; will print the filename. Restricting access is generally good practice, but can be a hassle if you don't care. You can bind a function with Function.prototype.bind , like so: js.func.bind(sk.getEnv())() . This is similar to passing a variable, but now the function's this refers to the skribi env rather than the module. If you want to define variables to be available to a script without explicitly passing them, you can store them in the skribi's this - which is the same object as sk.this , so that it can be accessed from a bound function. For example: this.x = \"foo\"; js.func.bind(sk.getEnv())(); with the script function func(){console.log(this.sk.this.x)}; module.exports = {func}; , will print \"foo\" . If you find the additional this annoying, and want it to work just like in a skribi, you can wrap the function's code in a with(this) {} block (See with for caveats). It's really up to you how how to design your scripts. When sharing them, you'll want to provide a reference implementation to help others understand how to use them.","title":"Scriptloader"},{"location":"scripting/modules/scriptloader/#scriptloader","text":"Any .js files inside of the configured Script Directory are automatically loaded by Skribi, and their exported properties made available in the js object. Any file modifications, additions, or deletions are detected and the modules reloaded automatically. Note: Obsidian by default does not show unrecognized file extensions in the file explorer, so .js files will not be visible. You may use a plugin such as CodeView to allow Obsidian to show JS files in the file explorer (as well as edit them within Obsidian). Personally, I use VSCode to edit my scriptloader scripts, by adding my script folder to my VSCode workspace. If for whatever reason you find the need to update the scriptloader manually (though this should never be necessary), you may either reload Obsidian or use the Skribi: Reload Scripts command.","title":"Scriptloader"},{"location":"scripting/modules/scriptloader/#exporting","text":"A module's exports consist of any properties belonging to the module.exports object. To export a property, assign to a property thereof, ex: module.exports.foo = property . Assigning to module.exports will overwrite the export object, which may or may not be desirable: module.exports = {fe, fi, fo} . In the following example, note that first function has no key, while the second does - functions are implicitly keyed with their name. This is not the case for other types, like numbers or strings - module.exports = {'foo', 2} is a syntax error. The statement module.exports = {fuctionOne, functionTwo: otherFunctionName, foo: 'fum'} would load as: js.moduleName: { functionOne: \u0192 functionOne() functionTwo: \u0192 otherFunctionName() foo: \"fum\" }","title":"Exporting"},{"location":"scripting/modules/scriptloader/#export-details","text":"The scriptloader has a couple extra features. Firstly, if you assign a string to exports._name , the file will be loaded under that string rather than the filename. Second, if you assign only one value (not counting _name ) to exports , that function will be available directly as js.moduleName() . If multiple values are present, the functions will be inside of js.moduleName , as in the example. This is a convenience feature - to prevent it, simply export more than one value. Or ask me to add a setting. When only one property is exported, the module key is determined by: module.exports._name , if it is a string. The key of the single value. Remember that functions are implicitly keyed. When multiple properties are exported, the module key is determined by: module.exports._name , if it is a string. The name of the source file. Tip: To inspect the js object, call console.log(js) in an evaluation tag. This will display the object in the dev console. If verbose logging is enabled, the loader will log whenever it loads a JS file. Additionally, a potentially confusing quirk of CJS module exports is the difference between module.exports and exports : the former is the actual object, while the latter is a shorthand proxy. You may assign to the properties of both objects and all will export successfully, but if you assign to either of them, this functionality will break. For example, exports = {foo} or module.exports = {foo} will cause exports to no longer contribute to the exported module - in this case, only module.exports will be exported. However, exports.foo = foo; module.exports.fum = fum; will load both foo and fum . For more information about this behavior, see Module Exports Shortcut . For information about exports in general, see Module Exports .","title":"Export Details"},{"location":"scripting/modules/scriptloader/#about-script-context","text":"The skribi context is just a teensy bit convoluted, especially if you're not familiar with this part of JS, so here's some extra info. Firstly, script functions are by default evaluated in their module closure, with no knowledge of the skribi context. Because of this, you do not need to export all of the definitions in your module - only the ones you want to access from skribi (See Javascript Closures and CommonJS Modules ). But what if we want to call skribi functions from the script? To easily give a script function access to the skribi context, you can pass the return of sk.getEnv() as an argument. In the script, that argument variable will now contain everything you normally have access to: js , int , etc. For example: js.func(sk.getEnv()) with the script function func(obj){console.log(obj.sk.ctx.file.basename)}; module.exports = {func}; will print the filename. Restricting access is generally good practice, but can be a hassle if you don't care. You can bind a function with Function.prototype.bind , like so: js.func.bind(sk.getEnv())() . This is similar to passing a variable, but now the function's this refers to the skribi env rather than the module. If you want to define variables to be available to a script without explicitly passing them, you can store them in the skribi's this - which is the same object as sk.this , so that it can be accessed from a bound function. For example: this.x = \"foo\"; js.func.bind(sk.getEnv())(); with the script function func(){console.log(this.sk.this.x)}; module.exports = {func}; , will print \"foo\" . If you find the additional this annoying, and want it to work just like in a skribi, you can wrap the function's code in a with(this) {} block (See with for caveats). It's really up to you how how to design your scripts. When sharing them, you'll want to provide a reference implementation to help others understand how to use them.","title":"About Script Context"},{"location":"scripting/modules/skribi/","text":".md-grid {max-width: 70rem;} Skribi Module Property of sk Type Description v {[key: string]: string} Contains variables passed to the template. In a non-template context, this object is empty. child Object Contains functions related to the MarkdownRenderChild . ctx Object Contains direct references to various objects. plugin: SkribosPlugin : A reference to the Skribi plugin. file?: TFile : The file inside of which the skribi is being rendered. Null if not being rendered inside of a file. app: App : The Obsidian app. this Object A reference to the template function's bound `this` object. Possibly useful for storing values to be accessed by scripts. sk.has(val: string) => boolean Returns true if the property val exists on sk.v . sk.render(text: string) => string Renders text as Obsidian Markdown inside a virtual element, then returns the element's innerHTML . sk.abort(msg?: string, data?: any) => void Aborts the render execution and renders an error block. Using this function provides finer control of error displays (useful for those making templates intended for use by others). If no arguments are provided, will render a generic 'abort' indicator. msg is equivalent to the message argument of an error constructor and may be null. The data argument can optionally contain additional properties. Valid properties (all optional): name: string - Overwrites error name. cls: string - CSS classes to apply to the error indicator, space separated. (default: 'skr-abort') hover: string - The message shown on mouse hover (default: msg or \"Evaluation Aborted\") label: string - The text shown in the block (default: 'sk') sk.getStyle(styleName: string) async => Promise<string> Returns a promise for the text content of the file styleName.css in the template directory, if it exists. Resolves on completion of initial template load (instant if already complete). sk.includeStyle(styleName: string) async => Promise< CSSStyleElement > Returns a promise for a style element that has been attached and scoped to the skribi, with the content of file styleName.css in the template directory. Resolves when both initial caching is complete and the skribi has been connected to the document (thus, awaiting this function directly will cause skribi to hang). Also causes the skribi to listen for and update on modifications to said css file. sk.up(key: string, value: any) => void Passes data up to the render process. Valid keys: noMarkdown - if truthy, markdown rendering will be skipped and the template function output treated as the innerHTML of the container element. You may still get rendered markdown with < %~ sk.render(markdownString) %> . sk.child Property of sk.child Type Description el HTMLDivElement The element to which the rendered `tR` nodes will be added. Note that this element is empty and not attached to the document until *after* the execution is complete. reload(id?: string) => void Force the skribi to re-process itself, unloading the current child in the process. If the skribi type is template, providing id will use a freshly retrieved version of that template as its source (used by Auto Reload ). registerInterval(cb: Function, t: number, ...args: any[]) => void Registers the function `cb` to be called every t seconds with the arguments args . Interval is cleared on unload. registerPost(cb: Function, ...args: any[]) => void Registers the function cb to be called after the skribi render function has been fullfilled and sk.child.el appended to the view. Called before embeds are rendered. registerUnload(cb: Function, ...args: any[]) => void Registers a function to called on child unload, which occurs when the element or child is destroyed. Use this to clear references as necessary. registerEvent(event: EventRef) => void Registers an EventRef to be safely offref'd on unload. addStyle(text: string) async => Promise< CSSStyleElement > Creates and attaches style element composed from the CSS-parsable string text . Returns a promise that resolves after the skribi function resolves and is attached to the document. Awaiting this value directly will thus cause the skribi function to hang. _c SkribiChild A direct reference to the child object. Not really intended to be accessed, just in case you wanna reach in there directly with your nasty code fingers.","title":"Skribi"},{"location":"scripting/modules/skribi/#skribi-module","text":"Property of sk Type Description v {[key: string]: string} Contains variables passed to the template. In a non-template context, this object is empty. child Object Contains functions related to the MarkdownRenderChild . ctx Object Contains direct references to various objects. plugin: SkribosPlugin : A reference to the Skribi plugin. file?: TFile : The file inside of which the skribi is being rendered. Null if not being rendered inside of a file. app: App : The Obsidian app. this Object A reference to the template function's bound `this` object. Possibly useful for storing values to be accessed by scripts. sk.has(val: string) => boolean Returns true if the property val exists on sk.v . sk.render(text: string) => string Renders text as Obsidian Markdown inside a virtual element, then returns the element's innerHTML . sk.abort(msg?: string, data?: any) => void Aborts the render execution and renders an error block. Using this function provides finer control of error displays (useful for those making templates intended for use by others). If no arguments are provided, will render a generic 'abort' indicator. msg is equivalent to the message argument of an error constructor and may be null. The data argument can optionally contain additional properties. Valid properties (all optional): name: string - Overwrites error name. cls: string - CSS classes to apply to the error indicator, space separated. (default: 'skr-abort') hover: string - The message shown on mouse hover (default: msg or \"Evaluation Aborted\") label: string - The text shown in the block (default: 'sk') sk.getStyle(styleName: string) async => Promise<string> Returns a promise for the text content of the file styleName.css in the template directory, if it exists. Resolves on completion of initial template load (instant if already complete). sk.includeStyle(styleName: string) async => Promise< CSSStyleElement > Returns a promise for a style element that has been attached and scoped to the skribi, with the content of file styleName.css in the template directory. Resolves when both initial caching is complete and the skribi has been connected to the document (thus, awaiting this function directly will cause skribi to hang). Also causes the skribi to listen for and update on modifications to said css file. sk.up(key: string, value: any) => void Passes data up to the render process. Valid keys: noMarkdown - if truthy, markdown rendering will be skipped and the template function output treated as the innerHTML of the container element. You may still get rendered markdown with < %~ sk.render(markdownString) %> .","title":"Skribi Module"},{"location":"scripting/modules/skribi/#skchild","text":"Property of sk.child Type Description el HTMLDivElement The element to which the rendered `tR` nodes will be added. Note that this element is empty and not attached to the document until *after* the execution is complete. reload(id?: string) => void Force the skribi to re-process itself, unloading the current child in the process. If the skribi type is template, providing id will use a freshly retrieved version of that template as its source (used by Auto Reload ). registerInterval(cb: Function, t: number, ...args: any[]) => void Registers the function `cb` to be called every t seconds with the arguments args . Interval is cleared on unload. registerPost(cb: Function, ...args: any[]) => void Registers the function cb to be called after the skribi render function has been fullfilled and sk.child.el appended to the view. Called before embeds are rendered. registerUnload(cb: Function, ...args: any[]) => void Registers a function to called on child unload, which occurs when the element or child is destroyed. Use this to clear references as necessary. registerEvent(event: EventRef) => void Registers an EventRef to be safely offref'd on unload. addStyle(text: string) async => Promise< CSSStyleElement > Creates and attaches style element composed from the CSS-parsable string text . Returns a promise that resolves after the skribi function resolves and is attached to the document. Awaiting this value directly will thus cause the skribi function to hang. _c SkribiChild A direct reference to the child object. Not really intended to be accessed, just in case you wanna reach in there directly with your nasty code fingers.","title":"sk.child"},{"location":"syntax/eta/","text":"Eta Basics First, review the Eta Syntax and related documentation and examples for a complete overview of the Eta format. Let's go over some details about how this process works. We will refer to the text sent to Eta as the input . The input is transformed into a JS function and executed, returning the string object tR , which is the output . Essentially, that is the core mechanism of Eta. In the input, untagged text will be output as text (in the JS function, it becomes an addition assignment to tR ). Text inside of Eta tags is evaluated as depending on the tag type: <% %> is the evaluation tag, where javascript is executed. To add text to the output, assign to tR . The addition assignment operator is useful in this context: tR += 'text to be appended . In this way, even a single eval tag can create an output. <%= %> is the interpolation tag - the value of its contents is coerced to a string and appended to tR . For example, <%= foo %> is equivalent to <% tR += (foo) %> . However, the contents are XML-escaped. <%~ %> is the raw interpolation tag - equivalent to interpolation, but the contents are not XML-escaped. After interpretation is complete, tR is rendered as Obsidian Markdown, creating HTML elements, which are then appended to the skribi element, which is then attached to the document. Examples of Eta Compilation The output functions in these examples are simplified for clarity (the actual functions have a bunch of extra stuff we don't need to think about right now). A very simple input, containing only A line of text. would be compiled to function () {tR += 'A line of text.'; return tR;} . Something more complicated, multiline code: <% let bool = true %> <% if (bool) { %> True <% } else { %> False <% } %> Compiles to: function() { let bool = true if (bool) { tR+='True\\n' } else { tR+='False\\n' } return tR; } In this way, hopefully the nature of Eta is a bit clearer.","title":"Eta Syntax"},{"location":"syntax/eta/#eta-basics","text":"First, review the Eta Syntax and related documentation and examples for a complete overview of the Eta format. Let's go over some details about how this process works. We will refer to the text sent to Eta as the input . The input is transformed into a JS function and executed, returning the string object tR , which is the output . Essentially, that is the core mechanism of Eta. In the input, untagged text will be output as text (in the JS function, it becomes an addition assignment to tR ). Text inside of Eta tags is evaluated as depending on the tag type: <% %> is the evaluation tag, where javascript is executed. To add text to the output, assign to tR . The addition assignment operator is useful in this context: tR += 'text to be appended . In this way, even a single eval tag can create an output. <%= %> is the interpolation tag - the value of its contents is coerced to a string and appended to tR . For example, <%= foo %> is equivalent to <% tR += (foo) %> . However, the contents are XML-escaped. <%~ %> is the raw interpolation tag - equivalent to interpolation, but the contents are not XML-escaped. After interpretation is complete, tR is rendered as Obsidian Markdown, creating HTML elements, which are then appended to the skribi element, which is then attached to the document.","title":"Eta Basics"},{"location":"syntax/eta/#examples-of-eta-compilation","text":"The output functions in these examples are simplified for clarity (the actual functions have a bunch of extra stuff we don't need to think about right now). A very simple input, containing only A line of text. would be compiled to function () {tR += 'A line of text.'; return tR;} . Something more complicated, multiline code: <% let bool = true %> <% if (bool) { %> True <% } else { %> False <% } %> Compiles to: function() { let bool = true if (bool) { tR+='True\\n' } else { tR+='False\\n' } return tR; } In this way, hopefully the nature of Eta is a bit clearer.","title":"Examples of Eta Compilation"},{"location":"syntax/skribi/","text":"Skribi Syntax Skribis are placed inside of inline or block code elements, and are processed asynchronously during markdown rendering. There are two primary types of skribis: template and non-template. The contents of template invocations are sent to the template, while that of non-templates are processed by Eta. To create an inline skribi, use curly brackets. There are four types of non-template flags that wrap the contents in Eta tags for convenience. {: } - Template : Invokes a template. {= } - Interpolate : Processed as <%= ... %> {~ } - Raw Interpolate : Processed as <%~ ... %> {. } - Evaluation : Processed as <% ... %> {{ }} - Literal : Processed as ... To use a codeblock, set the block's language to skribi or sk . Without a flag, these are processed literally, meaning that they must start and end with { } , just like an inline. To add a flag, suffix the type with -flag where flag is one of the following: int - Interpolate : Processed as {= ... } raw - Raw Interpolate : Processed as {~ ... } eval - Evaluate : Processed as {. ... } lit - Literal : Processed as {{ ... }}","title":"Skribi Syntax"},{"location":"syntax/skribi/#skribi-syntax","text":"Skribis are placed inside of inline or block code elements, and are processed asynchronously during markdown rendering. There are two primary types of skribis: template and non-template. The contents of template invocations are sent to the template, while that of non-templates are processed by Eta. To create an inline skribi, use curly brackets. There are four types of non-template flags that wrap the contents in Eta tags for convenience. {: } - Template : Invokes a template. {= } - Interpolate : Processed as <%= ... %> {~ } - Raw Interpolate : Processed as <%~ ... %> {. } - Evaluation : Processed as <% ... %> {{ }} - Literal : Processed as ... To use a codeblock, set the block's language to skribi or sk . Without a flag, these are processed literally, meaning that they must start and end with { } , just like an inline. To add a flag, suffix the type with -flag where flag is one of the following: int - Interpolate : Processed as {= ... } raw - Raw Interpolate : Processed as {~ ... } eval - Evaluate : Processed as {. ... } lit - Literal : Processed as {{ ... }}","title":"Skribi Syntax"},{"location":"syntax/style/","text":"Styling There are a few ways to include a style in your skribi. 1 : If you have a .css file in your templates directory, you can load it in your skribi with sk.includeStyle(style) where style is a string matching the filename of your .css file. Styles loaded in this way are not processed by Eta. You can also get the style snippet as text with sk.getStyle(style) . Styles loaded with sk.includeStyle() will cause the skribi to reload whenever the .css file is modified, just like it would if its template file was modified. 2 : Creating a <style> element directly in the skribi as you would create any other element. Currently, only the first style element will be processed. You can then use Eta syntax inside of the style element. 3 : To load any text as a stylesheet, use sk.child.addStyle(text) . text should be parsable CSS. Scoping The rules defined by a skribi style element will apply only to the skribi element, which makes styling your components easy. If you want to add a global stylesheet, you can of course still use JS to do so. When created through one of these methods, each style rule is automatically constrained. To see the rendered style, inspect the style element in the elements panel. The keyword :scope is replaced with the constraint selector, so you can target the skribi element body with :scope { ... } .","title":"Styling"},{"location":"syntax/style/#styling","text":"There are a few ways to include a style in your skribi. 1 : If you have a .css file in your templates directory, you can load it in your skribi with sk.includeStyle(style) where style is a string matching the filename of your .css file. Styles loaded in this way are not processed by Eta. You can also get the style snippet as text with sk.getStyle(style) . Styles loaded with sk.includeStyle() will cause the skribi to reload whenever the .css file is modified, just like it would if its template file was modified. 2 : Creating a <style> element directly in the skribi as you would create any other element. Currently, only the first style element will be processed. You can then use Eta syntax inside of the style element. 3 : To load any text as a stylesheet, use sk.child.addStyle(text) . text should be parsable CSS.","title":"Styling"},{"location":"syntax/style/#scoping","text":"The rules defined by a skribi style element will apply only to the skribi element, which makes styling your components easy. If you want to add a global stylesheet, you can of course still use JS to do so. When created through one of these methods, each style rule is automatically constrained. To see the rendered style, inspect the style element in the elements panel. The keyword :scope is replaced with the constraint selector, so you can target the skribi element body with :scope { ... } .","title":"Scoping"},{"location":"syntax/template_metadata/","text":"Template Metadata Frontmatter in a template file is omitted from the template, and used to inform Skribi about your template. To declare a field, add an entry with a key beginning with an underscore. When using the Insert Skribi command, you will be prompted to fill out the declared values. The value of the entry may be null or an object containing information about the field. Valid object keys: type : The type of field prompt. Defaults to \"string\", which currently the only valid type. name : Sets the label of the field in the prompt (defaults to field key) default : Sets the default value of the field in the prompt placeholder : Sets the 'ghost text' of the field in the prompt (will not be visible unless default is empty or null) Example of the frontmatter object syntax: --- _val: {default: Fum, name: Value} --- The above example will then prompt like so: Which will insert {:templatename | foo: Fum} .","title":"Template Metadata"},{"location":"syntax/template_metadata/#template-metadata","text":"Frontmatter in a template file is omitted from the template, and used to inform Skribi about your template. To declare a field, add an entry with a key beginning with an underscore. When using the Insert Skribi command, you will be prompted to fill out the declared values. The value of the entry may be null or an object containing information about the field. Valid object keys: type : The type of field prompt. Defaults to \"string\", which currently the only valid type. name : Sets the label of the field in the prompt (defaults to field key) default : Sets the default value of the field in the prompt placeholder : Sets the 'ghost text' of the field in the prompt (will not be visible unless default is empty or null) Example of the frontmatter object syntax: --- _val: {default: Fum, name: Value} --- The above example will then prompt like so: Which will insert {:templatename | foo: Fum} .","title":"Template Metadata"},{"location":"syntax/templates/","text":"Template Basics Skribi looks for template files in the configured Template Directory . Files with the extension .md or .eta are compiled and cached as templates. Files with the extension .css are cached as style snippets. In the event an .md file and an .eta file share a filename, only one will be loaded (so don't do that). Invoking a template is simple: for a template named template , the syntax would be {:template} . When invoked, variables can be passed to the template. The name and value are separated by a colon, and the variables are separated by pipes: | . Pipes inside variables must be backslash-escaped: \\| . To invoke template with the value foo set to Fum , the syntax would be: {:template | foo: Fum} . Values are interpreted as strings and whitespace trimmed. Working with Templates It's possible to work with your templates inside of Obsidian, but it's not designed for that purpose, and as a result writing JS/HTML/Eta in Obsidian is (in my opinion) rather unpleasant. I highly recommend using VSCode (or another external editor of your choice) and adding your template and script directories to your workspace. For the best experience, I also recommend the Eta Extension for VSCode to add support for .eta files. If it bothers you that it doesn't highlight the YAML template metadata properly, contact me and I'll tell you how to make it do that. When a template or script is modified externally, any skribis using them are automatically reloaded, so you can see your changes immediately.","title":"Templates"},{"location":"syntax/templates/#template-basics","text":"Skribi looks for template files in the configured Template Directory . Files with the extension .md or .eta are compiled and cached as templates. Files with the extension .css are cached as style snippets. In the event an .md file and an .eta file share a filename, only one will be loaded (so don't do that). Invoking a template is simple: for a template named template , the syntax would be {:template} . When invoked, variables can be passed to the template. The name and value are separated by a colon, and the variables are separated by pipes: | . Pipes inside variables must be backslash-escaped: \\| . To invoke template with the value foo set to Fum , the syntax would be: {:template | foo: Fum} . Values are interpreted as strings and whitespace trimmed.","title":"Template Basics"},{"location":"syntax/templates/#working-with-templates","text":"It's possible to work with your templates inside of Obsidian, but it's not designed for that purpose, and as a result writing JS/HTML/Eta in Obsidian is (in my opinion) rather unpleasant. I highly recommend using VSCode (or another external editor of your choice) and adding your template and script directories to your workspace. For the best experience, I also recommend the Eta Extension for VSCode to add support for .eta files. If it bothers you that it doesn't highlight the YAML template metadata properly, contact me and I'll tell you how to make it do that. When a template or script is modified externally, any skribis using them are automatically reloaded, so you can see your changes immediately.","title":"Working with Templates"}]}